# React - Part 3 - Layout

Let's make the site a bit less _primative_ by starting to include some styles, and setting up some themes.

## Fonts

At the moment the site is still using the font declarations that were generated by `create-react-app` - let's remove those now to see our site in all it's unstyled glory. In `/src/index.scss`, remove the existing `body` and `code` selectors and styles.

For the fastest rending speed, using [Web-safe fonts](https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Fundamentals#Web_safe_fonts) means no additional downloads should be necessary. But if you have a particular look in mind, then using a custom font is the way to go. There are two ways to implement this:

- Use [an online font service](https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Web_fonts#Using_an_online_font_service) such as [Google Fonts](https://www.google.com/fonts) (assuming that your font is publically available)
- Host the font files yourself

In this case we'll host the files ourselves. Install Fira Sans from NPM (or [feel free to choose another](https://github.com/KyleAMathews/typefaces))

```cmd
npm i typeface-fira-sans
```

We then just need to import them somewhere to hook them into the application. As they're gobal, `src/index.tsx` is arguably the best place. Add this to its imports:

```cmd
import 'typeface-fira-sans';
```

And finally, we need to apply the font in our `src/index.scss`. We'll apply it at the `body` level, so that everything will use it unless overridden.

```css
body {
  margin: 0;
  font-family: ('Fira Sans', 'Arial', 'sans-serif');
}
```

The Fira Sans fonts needed will now be downloaded by our site, based on what we use. (For example, if we use italics, then the appropriate italics version of the font will be downloaded, otherwise it won't be). We have also named our fallback fonts in case our preferred font is not working/available.

## Styling Defaults

We've already applied normalize to the CSS, in order to make the default consistent across browsers. However we didn't use a CSS Reset to "unstyle" the default elements. There are plenty of reset style screens available on the web, but rather than using one, we'll just explicit set some defaults that we want in `index.scss`.

```css
ol,
ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

a {
  cursor: pointer;
  color: inherit;
  text-decoration: none;
}

button {
  cursor: pointer;
  font-size: inherit;
  font-family: inherit;
  font-weight: inherit;
  font-style: inherit;
}
```

## Styling the Shell

Apply some styling to the Shell component, to actually lay out the components.

This will make use of CSS Grid, and if you have not used it before there's an excelent write-up on it at [CSS Tricks](https://css-tricks.com/snippets/css/complete-guide-grid/) that's worth going over. If you have half an hour, [this video from 2017](https://www.youtube.com/watch?v=7kVeCqQCxlk) is also well worth watching if you have a chance!

Create a new file called `views\components\application\Shell.module.scss` and add the contents below. This will put the header and nav at the top of the page, with the footer at the bottom. It will also add some basic styling to the nav items.

```scss
.root {
  display: grid;
  grid-template-columns: auto 1fr;
  grid-template-rows: auto 1fr auto;
  grid-template-areas:
    'header nav'
    'main main'
    'footer footer';

  > .header {
    grid-area: header;
  }

  > .nav {
    grid-area: nav;
  }

  > .main {
    grid-area: main;
  }

  > .footer {
    grid-area: footer;
  }
}

.header {
  display: grid;
  align-items: center;

  padding: 0.5rem 1rem;
  font-size: 1.5rem;
  letter-spacing: 0.125rem;

  em {
    opacity: 0.7;
  }
}

.nav {
  display: grid;
  align-items: center;

  > ul {
    display: grid;
    grid-auto-flow: column;
    grid-auto-columns: auto;
    justify-content: right;
    align-items: baseline;

    padding: 8px;
    gap: 8px;

    > li > a,
    > li > button {
      display: inline-block;
      padding: 8px 8px;
    }
  }
}

.main {
  padding: 1pc;
}

.footer {
  text-align: center;
  margin: 8px;
}
```

> Looking at the code above, you'll note that the selectors for the child elements (`header`, `nav`, etc.) are included twice - once in the `.root` when specifying the `grid-area`, and again further down on their own to apply additional styles.
>
> While the two selector statements could be combined to get the same result, I would encourage keeping them separate. `root` is concerned with _where_ the child elements should go, while _how_ they actually look is not relevant to it. This will also make splitting out a child element into its own file/module in future easier.

Now, import the new scss module file into the `Shell` component, and apply the styles to the relevant elements:

```tsx
...
import styles from './Shell.module.scss';

const Nav: React.FC = function () {
  return (
    <nav className={styles.nav}>
      ...
    </nav>
  );
};

export const Shell: React.FC = function ({ children }) {
  return (
    <div className={styles.root}>
      <header className={styles.header}>
        ...
      </header>
      <Nav />
      <main className={styles.main}>{children}</main>
      <footer className={styles.footer}>...</footer>
    </div>
  );
};
```

The running site should now lay out the elements a bit more sensibly, even if everything is still black and white. We'll fix that next.

## Colours

There are a number of goals we want to have when it comes to setting up colours on our site:

1. We want consistency - a primary button on one page should be the same colour as a primary button on a different page.
2. We don't want to have to specify explicit colours everywhere (no `#28177e` sprinkled throughout our code) so that we can change them without having to make lots of code changes.
3. Our site can have different themes applied easily
4. _Compile-time_ checking for our colour variables (because we can all make typos!)

We can cover the first three points by using [CSS Custom Properties](https://developer.mozilla.org/en-US/docs/Web/CSS/--*) (aka. CSS Variables), as they allow us to specify their value once, then use it everywhere in our application.

But there is no "compile-time checking" of the custom variable names that you write in code. _Any_ valid CSS Variable is potentially valid in the future, so if you make a typo in a variable name, you'll only know if you spot that the colour is not being applied.

A solution to point 4 is to **use SASS variables to specify our CSS variables**. This means the SASS compiler will complain if we use a variable that we haven't explcitly defined.

Create a new file at `src\styles\_colors.scss` with the following content:

```scss
// CSS variables
$_var-default: --color-default;
$_var-on-default: --color-on-default;
$_var-highlight: --color-highlight;
$_var-on-highlight: --color-on-highlight;
$_var-primary: --color-primary;
$_var-on-primary: --color-on-primary;
$_var-warning: --color-warning;
$_var-on-warning: --color-on-warning;
$_var-hover: --color-hover;
$_var-hover-hidden: --color-hover-hidden;
```

This code declares the CSS variables that we'll be using, and assigns their names into **private** (because of the leading underscore) SASS variables.

The names of the variables have been chosen specifically. Most of the colours are matched with an `on-` version, which is a colour that contrasts well with the original. They should be used in their pairs, as this makes applying new themes much easier.

> Note that the names do not actually have colour names (such as "red"). This is because when applying a colour, it shouldn't matter what the colour _actually is_, only that it'll work well with the other colours. That way, when themes are changed, everything still makes sense even though different themes may use totally different colours.

We're going to create two themes: "Light" and "Dark", and apply one depending on the [`prefers-color-scheme` media query](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme). Add the following to `_colors.scss` to create an `apply-theme` mixin:

```scss
@mixin apply-theme {
  $_hue-default: 212;
  $_hue-primary: 23;
  $_hue-warning: 28;

  #{$_var-default}: hsl($_hue-default, 5%, 95%);
  #{$_var-on-default}: hsl($_hue-default, 5%, 5%);
  #{$_var-highlight}: hsl($_hue-default, 75%, 45%);
  #{$_var-on-highlight}: hsl($_hue-default, 5%, 95%);
  #{$_var-primary}: hsl($_hue-primary, 75%, 45%);
  #{$_var-on-primary}: hsl($_hue-primary, 5%, 95%);
  #{$_var-warning}: hsl($_hue-warning, 100%, 50%);
  #{$_var-on-warning}: hsl($_hue-warning, 5%, 95%);
  #{$_var-hover}: rgb(255, 255, 255, 0.1);
  #{$_var-hover-hidden}: rgb(255, 255, 255, 0);

  @media (prefers-color-scheme: dark) {
    #{$_var-default}: hsl($_hue-default, 5%, 5%);
    #{$_var-on-default}: hsl($_hue-default, 5%, 95%);
    #{$_var-highlight}: hsl($_hue-default, 5%, 85%);
    #{$_var-on-highlight}: hsl($_hue-default, 95%, 45%);
    #{$_var-primary}: sl($_hue-primary, 5%, 85%);
    #{$_var-on-primary}: hsl($_hue-primary, 95%, 45%);
    #{$_var-warning}: hsl($_hue-warning, 80%, 50%);
    #{$_var-on-warning}: hsl($_hue-warning, 5%, 95%);
    #{$_var-hover}: rgb(0, 0, 0, 0.1);
    #{$_var-hover-hidden}: rgb(0, 0, 0, 0);
  }
}
```

> The colours above are nothing special, and feel free to customise them if you wish!

The code above is using the scss variables we defined earlier to set the values of the CSS variables. A media query will also apply a "dark" version if the user has specified that they prefer it.

There are a few other points of note:

- The code above is using `hsl` for colours, rather than the more common `rgb` or `#xxxxxx` styles. **This is optional**, but it allows us to [more easily see how different colours are related](https://css-tricks.com/yay-for-hsla/), as colours that use the same hue (the first value) are variations of the same colour.
- Because the colours are declared in a SCSS file, [SASS colour functions](https://sass-lang.com/documentation/modules/color) can be used if desired (but I find that they're less useful with using `hsl` colours, as the changes are already apparent).
- The "hover" and "hover-hidden" values are a bit different, as they'll be used to apply a hover style that just applies a bit of lightness/darkness to hoverable elements (such as links), but they work the same way as far as usage is concerned (using `rgb` vs `hsl` is an implementation detail for this file only).

Finally we'll add some public SASS variables to make getting the colours simple in the other SASS files that need them. Add the following to `_colors.scss`:

```scss
// SASS variables to get the CSS variable values
$default: var(#{$_var-default});
$on-default: var(#{$_var-on-default});
$highlight: var(#{$_var-highlight});
$on-highlight: var(#{$_var-on-highlight});
$primary: var(#{$_var-primary});
$on-primary: var(#{$_var-on-primary});
$warning: var(#{$_var-warning});
$on-warning: var(#{$_var-on-warning});
$hover: var(#{$_var-hover});
$hover-hidden: var(#{$_var-hover-hidden});
```

> Note that these variables don't need to "namespaced" with a "color" prefix or similar, as when we import the SASS module using `@use`, this will happen automatically.

Now that we have the "colour" module defined, we just need to use it!

First, apply the theme to the `body` element of the site, as this will ensure the values are available whereever in the DOM the components are rendered. Also apply the default background and foreground colours that will cascade to the child elements.

Update `src/index.scss` with the following:

```scss
@use 'src/styles/colors' as c;

...

body {
  @include c.apply-theme;

  background-color: c.$default;
  color: c.$on-default;
  ...
}
```

Then, update the `Shell` component to make the site a little less bland. Update `Shell.module.scss`:

```scss
@use 'src/styles/colors' as c;

@mixin setTitleBarColors() {
  background-color: c.$highlight;
  color: c.$on-highlight;
}

...

.header {
  @include setTitleBarColors();

  ...
}

.nav {
  @include setTitleBarColors();

  ...

  > ul {
    ...

    > li > a,
    > li > button {
      ...

      border: none;
      color: c.$on-highlight;

      background-color: c.$hover-hidden;
      transition: background-color 0.2s ease-in;

      &:hover {
        background-color: c.$hover;
      }
    }

    > li > a {
      border-bottom: solid 1px transparent;

      &:global(.active) {
        border-bottom-color: c.$on-highlight;
      }
    }
  }
}

...
```

You should now be able to run site and see some actual colours! Don't forget to change your preference for light vs. dark to see the alternate theme apply automatically.

## Responsive design

The final thing we'll add is to make the site responsive, as we can't really get away with "desktop only" sites much these days. Fortunately, using SASS and CSS Grid together, we can add some simple responsiveness without much trouble.

First install [the `include-media` library](https://eduardoboucas.github.io/include-media/), which makes adding media breakpoints simple (see the docs for examples of what it can do):

```cmd
npm i include-media
```

Then, create a new file at `src\styles\_media.scss` with the following contents to configure the library:

```scss
// Docs: https://eduardoboucas.github.io/include-media/
@import 'node_modules/include-media/dist/include-media.scss';

// Rather than using the standard "phone" / "tablet" / etc. breakpoints, just use a generic "small"
$breakpoints: (
  small: 640px,
);
```

> We're just going to have a single "small" breakpoint for screens less than or equal to 640px wide, but how many breakpoints (and what they're called) is up to you.

Finally, update `Shell.module.scss` with the following:

```scss
@use 'src/styles/media' as m;

...

.root {
  ...

  @include m.media('<=small') {
    grid-template-columns: 1fr;
    grid-template-rows: auto auto 1fr auto;
    grid-template-areas:
      'header'
      'nav'
      'main'
      'footer';
  }
}

...

.nav {
  ...

  > ul {
    ...

    @include m.media('<=small') {
      grid-auto-flow: row;
      justify-content: left;
      padding-top: 0;
      gap: 2px;
    }

    > li > a {
      ...
    }
  }
}
```

What this code does is update the layout of the CSS grid for the Shell root when the screen is "small". This rearranges the positioning of the Shell components, without having to override any other styles.

We do also override how the Nav renders its links, from a horizontal list, to a vertical one, while also changing the spacing a little.

## Summing Up

There was quite a lot going on this post! We've covered using custom fonts, applying some basic styling, together with automatic light/dark theming and responsiveness. In the next post, we'll look to actually getting the site secure.
